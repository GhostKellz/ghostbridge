# GhostBridge C/C++ Integration Guide

Complete guide for using GhostBridge (Cross-Chain Bridge Infrastructure) from C and C++ projects via C FFI bindings.

## Table of Contents

- [Overview](#overview)
- [Building C Bindings](#building-c-bindings)
- [C Usage](#c-usage)
- [C++ Wrapper](#c-wrapper)
- [CMake Integration](#cmake-integration)
- [Bridge Operations](#bridge-operations)
- [Cross-Chain Asset Management](#cross-chain-asset-management)
- [Error Handling](#error-handling)

## Overview

GhostBridge provides C bindings for cross-chain bridge operations, allowing C and C++ applications to interact with multiple blockchain networks. The bindings maintain security and reliability while providing familiar APIs for asset transfers, state synchronization, and cross-chain communication.

## Building C Bindings

### Rust Library Setup

Configure the Rust project for C-compatible binaries:

```toml
# Cargo.toml
[package]
name = "ghostbridge-c"
version = "0.1.0"
edition = "2021"

[lib]
name = "ghostbridge_c"
crate-type = ["cdylib", "staticlib"]

[dependencies]
ghostbridge = { version = "0.1", features = ["std", "ethereum", "bitcoin"] }
gcrypt = { version = "0.2", features = ["ed25519", "secp256k1"] }
tokio = { version = "1.0", features = ["rt-multi-thread"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
libc = "0.2"

[build-dependencies]
cbindgen = "0.24"
```

### Build Script for Header Generation

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_dir = PathBuf::from(&crate_dir).join("include");

    std::fs::create_dir_all(&output_dir).unwrap();

    let output_file = output_dir.join("ghostbridge.h");

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("GHOSTBRIDGE_H")
        .with_documentation(true)
        .with_autogen_warning("/* Auto-generated by cbindgen */")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(output_file);

    println!("cargo:rerun-if-changed=src/lib.rs");
}
```

### C FFI Implementation

```rust
// src/lib.rs
use ghostbridge::{Bridge, BridgeConfig, Asset, Transfer, Network};
use gcrypt::protocols::{Ed25519, Secp256k1};
use std::ptr;
use std::slice;
use std::ffi::{c_char, c_int, c_uint, c_void, CStr, CString};
use libc::size_t;
use tokio::runtime::Runtime;
use serde::{Serialize, Deserialize};

// Error codes
pub const GHOSTBRIDGE_SUCCESS: c_int = 0;
pub const GHOSTBRIDGE_ERROR_INVALID_INPUT: c_int = -1;
pub const GHOSTBRIDGE_ERROR_NETWORK_FAILED: c_int = -2;
pub const GHOSTBRIDGE_ERROR_TRANSFER_FAILED: c_int = -3;
pub const GHOSTBRIDGE_ERROR_INSUFFICIENT_FUNDS: c_int = -4;
pub const GHOSTBRIDGE_ERROR_INVALID_SIGNATURE: c_int = -5;
pub const GHOSTBRIDGE_ERROR_TIMEOUT: c_int = -6;
pub const GHOSTBRIDGE_ERROR_OUT_OF_MEMORY: c_int = -7;
pub const GHOSTBRIDGE_ERROR_SERIALIZATION_FAILED: c_int = -8;

// Network types
pub const GHOSTBRIDGE_NETWORK_ETHEREUM: c_int = 1;
pub const GHOSTBRIDGE_NETWORK_BITCOIN: c_int = 2;
pub const GHOSTBRIDGE_NETWORK_GHOSTCHAIN: c_int = 3;
pub const GHOSTBRIDGE_NETWORK_POLYGON: c_int = 4;
pub const GHOSTBRIDGE_NETWORK_BSC: c_int = 5;

// Asset types
pub const GHOSTBRIDGE_ASSET_ETH: c_int = 1;
pub const GHOSTBRIDGE_ASSET_BTC: c_int = 2;
pub const GHOSTBRIDGE_ASSET_GHOST: c_int = 3;
pub const GHOSTBRIDGE_ASSET_USDC: c_int = 4;
pub const GHOSTBRIDGE_ASSET_USDT: c_int = 5;

// Transfer status
pub const GHOSTBRIDGE_TRANSFER_PENDING: c_int = 0;
pub const GHOSTBRIDGE_TRANSFER_CONFIRMED: c_int = 1;
pub const GHOSTBRIDGE_TRANSFER_FAILED: c_int = 2;
pub const GHOSTBRIDGE_TRANSFER_COMPLETED: c_int = 3;

// Opaque handle types
#[repr(C)]
pub struct ghostbridge_bridge_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct ghostbridge_runtime_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct ghostbridge_transfer_t {
    _private: [u8; 0],
}

// Configuration structure
#[repr(C)]
#[derive(Debug, Clone)]
pub struct ghostbridge_config_t {
    pub ethereum_rpc_url: *const c_char,
    pub bitcoin_rpc_url: *const c_char,
    pub ghostchain_rpc_url: *const c_char,
    pub confirmation_blocks: u32,
    pub timeout_seconds: u64,
    pub max_gas_price: u64,
    pub enable_monitoring: c_int, // bool
}

// Asset information
#[repr(C)]
#[derive(Debug, Clone)]
pub struct ghostbridge_asset_t {
    pub asset_type: c_int,
    pub symbol: [c_char; 16],
    pub name: [c_char; 64],
    pub decimals: u8,
    pub contract_address: [c_char; 128], // For ERC-20 tokens
}

// Network information
#[repr(C)]
#[derive(Debug, Clone)]
pub struct ghostbridge_network_t {
    pub network_type: c_int,
    pub chain_id: u64,
    pub name: [c_char; 64],
    pub rpc_url: [c_char; 256],
    pub block_time_ms: u64,
}

// Transfer request
#[repr(C)]
#[derive(Debug, Clone)]
pub struct ghostbridge_transfer_request_t {
    pub from_network: c_int,
    pub to_network: c_int,
    pub asset_type: c_int,
    pub amount: [u8; 32], // Big-endian U256
    pub from_address: [c_char; 128],
    pub to_address: [c_char; 128],
    pub fee_amount: [u8; 32], // Big-endian U256
    pub nonce: u64,
}

// Transfer status
#[repr(C)]
#[derive(Debug, Clone)]
pub struct ghostbridge_transfer_status_t {
    pub transfer_id: [c_char; 128],
    pub status: c_int,
    pub from_tx_hash: [c_char; 128],
    pub to_tx_hash: [c_char; 128],
    pub confirmations: u32,
    pub required_confirmations: u32,
    pub created_at: u64,
    pub updated_at: u64,
}

// Balance information
#[repr(C)]
#[derive(Debug, Clone)]
pub struct ghostbridge_balance_t {
    pub network: c_int,
    pub asset_type: c_int,
    pub balance: [u8; 32], // Big-endian U256
    pub locked_balance: [u8; 32], // Big-endian U256
}

// Internal structures
struct InternalBridge {
    bridge: Bridge,
    runtime: Runtime,
}

struct InternalTransfer {
    transfer: Transfer,
}

// Version information
#[no_mangle]
pub extern "C" fn ghostbridge_version_string() -> *const c_char {
    b"ghostbridge 0.1.0\0".as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn ghostbridge_version_major() -> c_uint {
    0
}

#[no_mangle]
pub extern "C" fn ghostbridge_version_minor() -> c_uint {
    1
}

#[no_mangle]
pub extern "C" fn ghostbridge_version_patch() -> c_uint {
    0
}

// Runtime management
#[no_mangle]
pub extern "C" fn ghostbridge_runtime_new() -> *mut ghostbridge_runtime_t {
    let runtime = match Runtime::new() {
        Ok(rt) => rt,
        Err(_) => return ptr::null_mut(),
    };

    let boxed = Box::new(runtime);
    Box::into_raw(boxed) as *mut ghostbridge_runtime_t
}

#[no_mangle]
pub extern "C" fn ghostbridge_runtime_free(runtime: *mut ghostbridge_runtime_t) {
    if !runtime.is_null() {
        unsafe {
            let _ = Box::from_raw(runtime as *mut Runtime);
        }
    }
}

// Bridge management
#[no_mangle]
pub extern "C" fn ghostbridge_bridge_new(
    runtime: *mut ghostbridge_runtime_t,
    config: *const ghostbridge_config_t,
) -> *mut ghostbridge_bridge_t {
    if runtime.is_null() || config.is_null() {
        return ptr::null_mut();
    }

    let rt = unsafe { &*(runtime as *mut Runtime) };
    let cfg = unsafe { &*config };

    // Convert C config to Rust config
    let ethereum_rpc = if cfg.ethereum_rpc_url.is_null() {
        None
    } else {
        unsafe { CStr::from_ptr(cfg.ethereum_rpc_url).to_str().ok() }
    };

    let bitcoin_rpc = if cfg.bitcoin_rpc_url.is_null() {
        None
    } else {
        unsafe { CStr::from_ptr(cfg.bitcoin_rpc_url).to_str().ok() }
    };

    let ghostchain_rpc = if cfg.ghostchain_rpc_url.is_null() {
        None
    } else {
        unsafe { CStr::from_ptr(cfg.ghostchain_rpc_url).to_str().ok() }
    };

    let bridge_config = BridgeConfig {
        ethereum_rpc_url: ethereum_rpc.map(|s| s.to_string()),
        bitcoin_rpc_url: bitcoin_rpc.map(|s| s.to_string()),
        ghostchain_rpc_url: ghostchain_rpc.map(|s| s.to_string()),
        confirmation_blocks: cfg.confirmation_blocks,
        timeout_seconds: cfg.timeout_seconds,
        max_gas_price: cfg.max_gas_price,
        enable_monitoring: cfg.enable_monitoring != 0,
    };

    let bridge = match rt.block_on(async {
        Bridge::new(bridge_config).await
    }) {
        Ok(b) => b,
        Err(_) => return ptr::null_mut(),
    };

    let internal_bridge = InternalBridge {
        bridge,
        runtime: Runtime::new().unwrap(),
    };

    let boxed = Box::new(internal_bridge);
    Box::into_raw(boxed) as *mut ghostbridge_bridge_t
}

#[no_mangle]
pub extern "C" fn ghostbridge_bridge_free(bridge: *mut ghostbridge_bridge_t) {
    if !bridge.is_null() {
        unsafe {
            let _ = Box::from_raw(bridge as *mut InternalBridge);
        }
    }
}

// Network operations
#[no_mangle]
pub extern "C" fn ghostbridge_get_supported_networks(
    bridge: *mut ghostbridge_bridge_t,
    networks: *mut ghostbridge_network_t,
    max_networks: size_t,
    actual_count: *mut size_t,
) -> c_int {
    if bridge.is_null() || networks.is_null() || actual_count.is_null() {
        return GHOSTBRIDGE_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };

    // Get supported networks
    let supported_networks = vec![
        ghostbridge_network_t {
            network_type: GHOSTBRIDGE_NETWORK_ETHEREUM,
            chain_id: 1,
            name: {
                let mut name = [0; 64];
                let src = b"Ethereum Mainnet\0";
                name[..src.len()].copy_from_slice(src);
                name
            },
            rpc_url: {
                let mut url = [0; 256];
                let src = b"https://mainnet.infura.io/v3/YOUR_KEY\0";
                url[..src.len()].copy_from_slice(src);
                url
            },
            block_time_ms: 12000,
        },
        ghostbridge_network_t {
            network_type: GHOSTBRIDGE_NETWORK_BITCOIN,
            chain_id: 0,
            name: {
                let mut name = [0; 64];
                let src = b"Bitcoin Mainnet\0";
                name[..src.len()].copy_from_slice(src);
                name
            },
            rpc_url: {
                let mut url = [0; 256];
                let src = b"https://bitcoin-rpc.example.com\0";
                url[..url.len().min(src.len())].copy_from_slice(&src[..url.len().min(src.len())]);
                url
            },
            block_time_ms: 600000,
        },
        ghostbridge_network_t {
            network_type: GHOSTBRIDGE_NETWORK_GHOSTCHAIN,
            chain_id: 9999,
            name: {
                let mut name = [0; 64];
                let src = b"GhostChain Mainnet\0";
                name[..src.len()].copy_from_slice(src);
                name
            },
            rpc_url: {
                let mut url = [0; 256];
                let src = b"https://rpc.ghostchain.io\0";
                url[..src.len()].copy_from_slice(src);
                url
            },
            block_time_ms: 3000,
        },
    ];

    let count = supported_networks.len().min(max_networks);
    unsafe {
        for (i, network) in supported_networks.iter().take(count).enumerate() {
            *networks.add(i) = network.clone();
        }
        *actual_count = supported_networks.len();
    }

    GHOSTBRIDGE_SUCCESS
}

#[no_mangle]
pub extern "C" fn ghostbridge_get_supported_assets(
    bridge: *mut ghostbridge_bridge_t,
    network: c_int,
    assets: *mut ghostbridge_asset_t,
    max_assets: size_t,
    actual_count: *mut size_t,
) -> c_int {
    if bridge.is_null() || assets.is_null() || actual_count.is_null() {
        return GHOSTBRIDGE_ERROR_INVALID_INPUT;
    }

    let supported_assets = match network {
        GHOSTBRIDGE_NETWORK_ETHEREUM => vec![
            ghostbridge_asset_t {
                asset_type: GHOSTBRIDGE_ASSET_ETH,
                symbol: {
                    let mut symbol = [0; 16];
                    let src = b"ETH\0";
                    symbol[..src.len()].copy_from_slice(src);
                    symbol
                },
                name: {
                    let mut name = [0; 64];
                    let src = b"Ethereum\0";
                    name[..src.len()].copy_from_slice(src);
                    name
                },
                decimals: 18,
                contract_address: [0; 128], // Native ETH
            },
            ghostbridge_asset_t {
                asset_type: GHOSTBRIDGE_ASSET_USDC,
                symbol: {
                    let mut symbol = [0; 16];
                    let src = b"USDC\0";
                    symbol[..src.len()].copy_from_slice(src);
                    symbol
                },
                name: {
                    let mut name = [0; 64];
                    let src = b"USD Coin\0";
                    name[..src.len()].copy_from_slice(src);
                    name
                },
                decimals: 6,
                contract_address: {
                    let mut addr = [0; 128];
                    let src = b"0xA0b86a33E6441B8dB2B6f66b6Dc01234567890AB\0";
                    addr[..src.len()].copy_from_slice(src);
                    addr
                },
            },
        ],
        GHOSTBRIDGE_NETWORK_BITCOIN => vec![
            ghostbridge_asset_t {
                asset_type: GHOSTBRIDGE_ASSET_BTC,
                symbol: {
                    let mut symbol = [0; 16];
                    let src = b"BTC\0";
                    symbol[..src.len()].copy_from_slice(src);
                    symbol
                },
                name: {
                    let mut name = [0; 64];
                    let src = b"Bitcoin\0";
                    name[..src.len()].copy_from_slice(src);
                    name
                },
                decimals: 8,
                contract_address: [0; 128], // Native Bitcoin
            },
        ],
        GHOSTBRIDGE_NETWORK_GHOSTCHAIN => vec![
            ghostbridge_asset_t {
                asset_type: GHOSTBRIDGE_ASSET_GHOST,
                symbol: {
                    let mut symbol = [0; 16];
                    let src = b"GHOST\0";
                    symbol[..src.len()].copy_from_slice(src);
                    symbol
                },
                name: {
                    let mut name = [0; 64];
                    let src = b"GhostChain Token\0";
                    name[..src.len()].copy_from_slice(src);
                    name
                },
                decimals: 18,
                contract_address: [0; 128], // Native GHOST
            },
        ],
        _ => vec![],
    };

    let count = supported_assets.len().min(max_assets);
    unsafe {
        for (i, asset) in supported_assets.iter().take(count).enumerate() {
            *assets.add(i) = asset.clone();
        }
        *actual_count = supported_assets.len();
    }

    GHOSTBRIDGE_SUCCESS
}

// Balance operations
#[no_mangle]
pub extern "C" fn ghostbridge_get_balance(
    bridge: *mut ghostbridge_bridge_t,
    network: c_int,
    asset_type: c_int,
    address: *const c_char,
    balance: *mut ghostbridge_balance_t,
) -> c_int {
    if bridge.is_null() || address.is_null() || balance.is_null() {
        return GHOSTBRIDGE_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };

    let addr_str = unsafe {
        match CStr::from_ptr(address).to_str() {
            Ok(s) => s,
            Err(_) => return GHOSTBRIDGE_ERROR_INVALID_INPUT,
        }
    };

    // Get balance (simplified implementation)
    let balance_result = internal_bridge.runtime.block_on(async {
        // In real implementation, this would call the actual bridge
        Ok((1000000000000000000u128, 0u128)) // 1 ETH, 0 locked
    });

    match balance_result {
        Ok((bal, locked)) => {
            unsafe {
                (*balance).network = network;
                (*balance).asset_type = asset_type;
                (*balance).balance = bal.to_be_bytes();
                (*balance).locked_balance = locked.to_be_bytes();
            }
            GHOSTBRIDGE_SUCCESS
        }
        Err(_) => GHOSTBRIDGE_ERROR_NETWORK_FAILED,
    }
}

// Transfer operations
#[no_mangle]
pub extern "C" fn ghostbridge_create_transfer(
    bridge: *mut ghostbridge_bridge_t,
    request: *const ghostbridge_transfer_request_t,
    private_key: *const u8,
    private_key_len: size_t,
) -> *mut ghostbridge_transfer_t {
    if bridge.is_null() || request.is_null() || private_key.is_null() {
        return ptr::null_mut();
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };
    let req = unsafe { &*request };

    let key_slice = unsafe { slice::from_raw_parts(private_key, private_key_len) };

    // Create transfer (simplified implementation)
    let transfer_result = internal_bridge.runtime.block_on(async {
        // In real implementation, this would create the actual transfer
        Transfer::new(/* transfer parameters */)
    });

    match transfer_result {
        Ok(transfer) => {
            let internal_transfer = InternalTransfer { transfer };
            let boxed = Box::new(internal_transfer);
            Box::into_raw(boxed) as *mut ghostbridge_transfer_t
        }
        Err(_) => ptr::null_mut(),
    }
}

#[no_mangle]
pub extern "C" fn ghostbridge_submit_transfer(
    bridge: *mut ghostbridge_bridge_t,
    transfer: *mut ghostbridge_transfer_t,
) -> c_int {
    if bridge.is_null() || transfer.is_null() {
        return GHOSTBRIDGE_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };
    let internal_transfer = unsafe { &*(transfer as *mut InternalTransfer) };

    // Submit transfer
    let result = internal_bridge.runtime.block_on(async {
        // In real implementation, this would submit to the network
        Ok(())
    });

    match result {
        Ok(_) => GHOSTBRIDGE_SUCCESS,
        Err(_) => GHOSTBRIDGE_ERROR_TRANSFER_FAILED,
    }
}

#[no_mangle]
pub extern "C" fn ghostbridge_get_transfer_status(
    bridge: *mut ghostbridge_bridge_t,
    transfer_id: *const c_char,
    status: *mut ghostbridge_transfer_status_t,
) -> c_int {
    if bridge.is_null() || transfer_id.is_null() || status.is_null() {
        return GHOSTBRIDGE_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };

    let id_str = unsafe {
        match CStr::from_ptr(transfer_id).to_str() {
            Ok(s) => s,
            Err(_) => return GHOSTBRIDGE_ERROR_INVALID_INPUT,
        }
    };

    // Get transfer status
    let status_result = internal_bridge.runtime.block_on(async {
        // In real implementation, this would query the bridge
        Ok(Transfer::Status {
            id: id_str.to_string(),
            status: Transfer::StatusType::Pending,
            from_tx: None,
            to_tx: None,
            confirmations: 0,
            required_confirmations: 12,
            created_at: 1234567890,
            updated_at: 1234567890,
        })
    });

    match status_result {
        Ok(transfer_status) => {
            unsafe {
                // Copy transfer ID
                let id_bytes = transfer_status.id.as_bytes();
                let id_len = id_bytes.len().min(127);
                (*status).transfer_id[..id_len].copy_from_slice(&id_bytes[..id_len]);
                (*status).transfer_id[id_len] = 0;

                (*status).status = match transfer_status.status {
                    Transfer::StatusType::Pending => GHOSTBRIDGE_TRANSFER_PENDING,
                    Transfer::StatusType::Confirmed => GHOSTBRIDGE_TRANSFER_CONFIRMED,
                    Transfer::StatusType::Failed => GHOSTBRIDGE_TRANSFER_FAILED,
                    Transfer::StatusType::Completed => GHOSTBRIDGE_TRANSFER_COMPLETED,
                };

                (*status).confirmations = transfer_status.confirmations;
                (*status).required_confirmations = transfer_status.required_confirmations;
                (*status).created_at = transfer_status.created_at;
                (*status).updated_at = transfer_status.updated_at;
            }
            GHOSTBRIDGE_SUCCESS
        }
        Err(_) => GHOSTBRIDGE_ERROR_NETWORK_FAILED,
    }
}

#[no_mangle]
pub extern "C" fn ghostbridge_transfer_free(transfer: *mut ghostbridge_transfer_t) {
    if !transfer.is_null() {
        unsafe {
            let _ = Box::from_raw(transfer as *mut InternalTransfer);
        }
    }
}

// Utility functions
#[no_mangle]
pub extern "C" fn ghostbridge_error_string(error_code: c_int) -> *const c_char {
    match error_code {
        GHOSTBRIDGE_SUCCESS => b"Success\0",
        GHOSTBRIDGE_ERROR_INVALID_INPUT => b"Invalid input\0",
        GHOSTBRIDGE_ERROR_NETWORK_FAILED => b"Network operation failed\0",
        GHOSTBRIDGE_ERROR_TRANSFER_FAILED => b"Transfer failed\0",
        GHOSTBRIDGE_ERROR_INSUFFICIENT_FUNDS => b"Insufficient funds\0",
        GHOSTBRIDGE_ERROR_INVALID_SIGNATURE => b"Invalid signature\0",
        GHOSTBRIDGE_ERROR_TIMEOUT => b"Operation timed out\0",
        GHOSTBRIDGE_ERROR_OUT_OF_MEMORY => b"Out of memory\0",
        GHOSTBRIDGE_ERROR_SERIALIZATION_FAILED => b"Serialization failed\0",
        _ => b"Unknown error\0",
    }.as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn ghostbridge_network_name(network: c_int) -> *const c_char {
    match network {
        GHOSTBRIDGE_NETWORK_ETHEREUM => b"Ethereum\0",
        GHOSTBRIDGE_NETWORK_BITCOIN => b"Bitcoin\0",
        GHOSTBRIDGE_NETWORK_GHOSTCHAIN => b"GhostChain\0",
        GHOSTBRIDGE_NETWORK_POLYGON => b"Polygon\0",
        GHOSTBRIDGE_NETWORK_BSC => b"Binance Smart Chain\0",
        _ => b"Unknown\0",
    }.as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn ghostbridge_asset_name(asset_type: c_int) -> *const c_char {
    match asset_type {
        GHOSTBRIDGE_ASSET_ETH => b"Ethereum\0",
        GHOSTBRIDGE_ASSET_BTC => b"Bitcoin\0",
        GHOSTBRIDGE_ASSET_GHOST => b"GhostChain Token\0",
        GHOSTBRIDGE_ASSET_USDC => b"USD Coin\0",
        GHOSTBRIDGE_ASSET_USDT => b"Tether USD\0",
        _ => b"Unknown\0",
    }.as_ptr() as *const c_char
}
```

### Generated C Header

```c
/* Auto-generated by cbindgen */

#ifndef GHOSTBRIDGE_H
#define GHOSTBRIDGE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Error codes
 */
#define GHOSTBRIDGE_SUCCESS 0
#define GHOSTBRIDGE_ERROR_INVALID_INPUT -1
#define GHOSTBRIDGE_ERROR_NETWORK_FAILED -2
#define GHOSTBRIDGE_ERROR_TRANSFER_FAILED -3
#define GHOSTBRIDGE_ERROR_INSUFFICIENT_FUNDS -4
#define GHOSTBRIDGE_ERROR_INVALID_SIGNATURE -5
#define GHOSTBRIDGE_ERROR_TIMEOUT -6
#define GHOSTBRIDGE_ERROR_OUT_OF_MEMORY -7
#define GHOSTBRIDGE_ERROR_SERIALIZATION_FAILED -8

/**
 * Network types
 */
#define GHOSTBRIDGE_NETWORK_ETHEREUM 1
#define GHOSTBRIDGE_NETWORK_BITCOIN 2
#define GHOSTBRIDGE_NETWORK_GHOSTCHAIN 3
#define GHOSTBRIDGE_NETWORK_POLYGON 4
#define GHOSTBRIDGE_NETWORK_BSC 5

/**
 * Asset types
 */
#define GHOSTBRIDGE_ASSET_ETH 1
#define GHOSTBRIDGE_ASSET_BTC 2
#define GHOSTBRIDGE_ASSET_GHOST 3
#define GHOSTBRIDGE_ASSET_USDC 4
#define GHOSTBRIDGE_ASSET_USDT 5

/**
 * Transfer status
 */
#define GHOSTBRIDGE_TRANSFER_PENDING 0
#define GHOSTBRIDGE_TRANSFER_CONFIRMED 1
#define GHOSTBRIDGE_TRANSFER_FAILED 2
#define GHOSTBRIDGE_TRANSFER_COMPLETED 3

/**
 * Opaque bridge handle
 */
typedef struct ghostbridge_bridge_t ghostbridge_bridge_t;

/**
 * Opaque runtime handle
 */
typedef struct ghostbridge_runtime_t ghostbridge_runtime_t;

/**
 * Opaque transfer handle
 */
typedef struct ghostbridge_transfer_t ghostbridge_transfer_t;

/**
 * Bridge configuration
 */
typedef struct ghostbridge_config_t {
  const char *ethereum_rpc_url;
  const char *bitcoin_rpc_url;
  const char *ghostchain_rpc_url;
  uint32_t confirmation_blocks;
  uint64_t timeout_seconds;
  uint64_t max_gas_price;
  int enable_monitoring;
} ghostbridge_config_t;

/**
 * Asset information
 */
typedef struct ghostbridge_asset_t {
  int asset_type;
  char symbol[16];
  char name[64];
  uint8_t decimals;
  char contract_address[128];
} ghostbridge_asset_t;

/**
 * Network information
 */
typedef struct ghostbridge_network_t {
  int network_type;
  uint64_t chain_id;
  char name[64];
  char rpc_url[256];
  uint64_t block_time_ms;
} ghostbridge_network_t;

/**
 * Transfer request
 */
typedef struct ghostbridge_transfer_request_t {
  int from_network;
  int to_network;
  int asset_type;
  uint8_t amount[32];
  char from_address[128];
  char to_address[128];
  uint8_t fee_amount[32];
  uint64_t nonce;
} ghostbridge_transfer_request_t;

/**
 * Transfer status
 */
typedef struct ghostbridge_transfer_status_t {
  char transfer_id[128];
  int status;
  char from_tx_hash[128];
  char to_tx_hash[128];
  uint32_t confirmations;
  uint32_t required_confirmations;
  uint64_t created_at;
  uint64_t updated_at;
} ghostbridge_transfer_status_t;

/**
 * Balance information
 */
typedef struct ghostbridge_balance_t {
  int network;
  int asset_type;
  uint8_t balance[32];
  uint8_t locked_balance[32];
} ghostbridge_balance_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get GhostBridge version string
 */
const char *ghostbridge_version_string(void);

/**
 * Get major version number
 */
unsigned int ghostbridge_version_major(void);

/**
 * Get minor version number
 */
unsigned int ghostbridge_version_minor(void);

/**
 * Get patch version number
 */
unsigned int ghostbridge_version_patch(void);

/**
 * Create a new async runtime
 */
ghostbridge_runtime_t *ghostbridge_runtime_new(void);

/**
 * Free async runtime
 */
void ghostbridge_runtime_free(ghostbridge_runtime_t *runtime);

/**
 * Create a new bridge instance
 */
ghostbridge_bridge_t *ghostbridge_bridge_new(ghostbridge_runtime_t *runtime,
                                            const ghostbridge_config_t *config);

/**
 * Free bridge instance
 */
void ghostbridge_bridge_free(ghostbridge_bridge_t *bridge);

/**
 * Get supported networks
 */
int ghostbridge_get_supported_networks(ghostbridge_bridge_t *bridge,
                                     ghostbridge_network_t *networks,
                                     size_t max_networks,
                                     size_t *actual_count);

/**
 * Get supported assets for a network
 */
int ghostbridge_get_supported_assets(ghostbridge_bridge_t *bridge,
                                   int network,
                                   ghostbridge_asset_t *assets,
                                   size_t max_assets,
                                   size_t *actual_count);

/**
 * Get balance for an address
 */
int ghostbridge_get_balance(ghostbridge_bridge_t *bridge,
                          int network,
                          int asset_type,
                          const char *address,
                          ghostbridge_balance_t *balance);

/**
 * Create a new transfer
 */
ghostbridge_transfer_t *ghostbridge_create_transfer(ghostbridge_bridge_t *bridge,
                                                   const ghostbridge_transfer_request_t *request,
                                                   const uint8_t *private_key,
                                                   size_t private_key_len);

/**
 * Submit transfer to the network
 */
int ghostbridge_submit_transfer(ghostbridge_bridge_t *bridge,
                              ghostbridge_transfer_t *transfer);

/**
 * Get transfer status
 */
int ghostbridge_get_transfer_status(ghostbridge_bridge_t *bridge,
                                  const char *transfer_id,
                                  ghostbridge_transfer_status_t *status);

/**
 * Free transfer
 */
void ghostbridge_transfer_free(ghostbridge_transfer_t *transfer);

/**
 * Get error message for error code
 */
const char *ghostbridge_error_string(int error_code);

/**
 * Get network name
 */
const char *ghostbridge_network_name(int network);

/**
 * Get asset name
 */
const char *ghostbridge_asset_name(int asset_type);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* GHOSTBRIDGE_H */
```

## C Usage

### Basic C Example

```c
// bridge_example.c
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "ghostbridge.h"

void print_networks(ghostbridge_bridge_t *bridge);
void test_balance_query(ghostbridge_bridge_t *bridge);
void test_cross_chain_transfer(ghostbridge_bridge_t *bridge);

int main() {
    printf("GhostBridge version: %s\n", ghostbridge_version_string());

    // Create runtime
    ghostbridge_runtime_t *runtime = ghostbridge_runtime_new();
    assert(runtime != NULL);

    // Configure bridge
    ghostbridge_config_t config = {
        .ethereum_rpc_url = "https://mainnet.infura.io/v3/YOUR_KEY",
        .bitcoin_rpc_url = "https://bitcoin-rpc.example.com",
        .ghostchain_rpc_url = "https://rpc.ghostchain.io",
        .confirmation_blocks = 12,
        .timeout_seconds = 300,
        .max_gas_price = 100000000000, // 100 gwei
        .enable_monitoring = 1,
    };

    // Create bridge
    ghostbridge_bridge_t *bridge = ghostbridge_bridge_new(runtime, &config);
    assert(bridge != NULL);

    printf("✓ GhostBridge initialized successfully\n");

    // Test bridge operations
    print_networks(bridge);
    test_balance_query(bridge);
    test_cross_chain_transfer(bridge);

    // Cleanup
    ghostbridge_bridge_free(bridge);
    ghostbridge_runtime_free(runtime);

    printf("GhostBridge example completed!\n");
    return 0;
}

void print_networks(ghostbridge_bridge_t *bridge) {
    printf("\n=== Supported Networks ===\n");

    ghostbridge_network_t networks[10];
    size_t actual_count;

    int result = ghostbridge_get_supported_networks(
        bridge,
        networks,
        10,
        &actual_count
    );

    if (result == GHOSTBRIDGE_SUCCESS) {
        printf("Found %zu supported networks:\n", actual_count);
        for (size_t i = 0; i < actual_count; i++) {
            printf("- %s (Chain ID: %lu, Block time: %lu ms)\n",
                   networks[i].name,
                   networks[i].chain_id,
                   networks[i].block_time_ms);
        }
    } else {
        printf("Failed to get networks: %s\n", ghostbridge_error_string(result));
    }
}

void test_balance_query(ghostbridge_bridge_t *bridge) {
    printf("\n=== Balance Query Test ===\n");

    ghostbridge_balance_t balance;
    int result = ghostbridge_get_balance(
        bridge,
        GHOSTBRIDGE_NETWORK_ETHEREUM,
        GHOSTBRIDGE_ASSET_ETH,
        "0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B",
        &balance
    );

    if (result == GHOSTBRIDGE_SUCCESS) {
        printf("✓ Balance query successful\n");
        printf("Network: %s\n", ghostbridge_network_name(balance.network));
        printf("Asset: %s\n", ghostbridge_asset_name(balance.asset_type));
        // Note: In real implementation, you'd convert the U256 balance to a readable format
    } else {
        printf("✗ Balance query failed: %s\n", ghostbridge_error_string(result));
    }
}

void test_cross_chain_transfer(ghostbridge_bridge_t *bridge) {
    printf("\n=== Cross-Chain Transfer Test ===\n");

    // Create transfer request
    ghostbridge_transfer_request_t request = {
        .from_network = GHOSTBRIDGE_NETWORK_ETHEREUM,
        .to_network = GHOSTBRIDGE_NETWORK_GHOSTCHAIN,
        .asset_type = GHOSTBRIDGE_ASSET_ETH,
        .nonce = 1,
    };

    // Set amount (1 ETH = 1e18 wei)
    // This is a simplified representation - in practice you'd use proper U256 handling
    memset(request.amount, 0, 32);
    request.amount[31] = 1; // Very small amount for demonstration

    strcpy(request.from_address, "0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B");
    strcpy(request.to_address, "ghost1abcd1234567890abcd1234567890abcd123456");

    // Example private key (32 bytes) - DON'T USE IN PRODUCTION
    uint8_t private_key[32] = {
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
        0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20
    };

    // Create transfer
    ghostbridge_transfer_t *transfer = ghostbridge_create_transfer(
        bridge,
        &request,
        private_key,
        32
    );

    if (transfer != NULL) {
        printf("✓ Transfer created successfully\n");

        // Submit transfer
        int result = ghostbridge_submit_transfer(bridge, transfer);
        if (result == GHOSTBRIDGE_SUCCESS) {
            printf("✓ Transfer submitted to network\n");

            // Check status
            ghostbridge_transfer_status_t status;
            result = ghostbridge_get_transfer_status(
                bridge,
                "example_transfer_id",
                &status
            );

            if (result == GHOSTBRIDGE_SUCCESS) {
                printf("✓ Transfer status: %d\n", status.status);
                printf("  Confirmations: %u/%u\n",
                       status.confirmations,
                       status.required_confirmations);
            }
        } else {
            printf("✗ Transfer submission failed: %s\n",
                   ghostbridge_error_string(result));
        }

        ghostbridge_transfer_free(transfer);
    } else {
        printf("✗ Failed to create transfer\n");
    }
}
```

## C++ Wrapper

### Modern C++ Wrapper

```cpp
// ghostbridge.hpp
#ifndef GHOSTBRIDGE_HPP
#define GHOSTBRIDGE_HPP

#include <string>
#include <vector>
#include <memory>
#include <stdexcept>
#include <chrono>
#include <cstring>
#include "ghostbridge.h"

namespace ghostbridge {

class BridgeError : public std::runtime_error {
public:
    explicit BridgeError(int error_code)
        : std::runtime_error(ghostbridge_error_string(error_code))
        , code_(error_code) {}

    int code() const { return code_; }

private:
    int code_;
};

// Helper class for big integer handling
class U256 {
public:
    U256() { std::fill(data_.begin(), data_.end(), 0); }

    explicit U256(uint64_t value) {
        std::fill(data_.begin(), data_.end(), 0);
        // Store in big-endian format
        for (int i = 7; i >= 0; --i) {
            data_[24 + i] = static_cast<uint8_t>(value & 0xFF);
            value >>= 8;
        }
    }

    explicit U256(const std::array<uint8_t, 32>& bytes) : data_(bytes) {}

    const std::array<uint8_t, 32>& bytes() const { return data_; }

    uint64_t to_u64() const {
        uint64_t result = 0;
        for (int i = 0; i < 8; ++i) {
            result = (result << 8) | data_[24 + i];
        }
        return result;
    }

    std::string to_string() const {
        // Simplified string conversion
        return std::to_string(to_u64());
    }

private:
    std::array<uint8_t, 32> data_;
};

enum class Network {
    Ethereum = GHOSTBRIDGE_NETWORK_ETHEREUM,
    Bitcoin = GHOSTBRIDGE_NETWORK_BITCOIN,
    GhostChain = GHOSTBRIDGE_NETWORK_GHOSTCHAIN,
    Polygon = GHOSTBRIDGE_NETWORK_POLYGON,
    BSC = GHOSTBRIDGE_NETWORK_BSC,
};

enum class AssetType {
    ETH = GHOSTBRIDGE_ASSET_ETH,
    BTC = GHOSTBRIDGE_ASSET_BTC,
    GHOST = GHOSTBRIDGE_ASSET_GHOST,
    USDC = GHOSTBRIDGE_ASSET_USDC,
    USDT = GHOSTBRIDGE_ASSET_USDT,
};

enum class TransferStatus {
    Pending = GHOSTBRIDGE_TRANSFER_PENDING,
    Confirmed = GHOSTBRIDGE_TRANSFER_CONFIRMED,
    Failed = GHOSTBRIDGE_TRANSFER_FAILED,
    Completed = GHOSTBRIDGE_TRANSFER_COMPLETED,
};

struct NetworkInfo {
    Network network;
    uint64_t chain_id;
    std::string name;
    std::string rpc_url;
    std::chrono::milliseconds block_time;

    static NetworkInfo from_native(const ghostbridge_network_t& native) {
        return NetworkInfo{
            .network = static_cast<Network>(native.network_type),
            .chain_id = native.chain_id,
            .name = std::string(native.name),
            .rpc_url = std::string(native.rpc_url),
            .block_time = std::chrono::milliseconds(native.block_time_ms),
        };
    }
};

struct AssetInfo {
    AssetType asset_type;
    std::string symbol;
    std::string name;
    uint8_t decimals;
    std::string contract_address;

    static AssetInfo from_native(const ghostbridge_asset_t& native) {
        return AssetInfo{
            .asset_type = static_cast<AssetType>(native.asset_type),
            .symbol = std::string(native.symbol),
            .name = std::string(native.name),
            .decimals = native.decimals,
            .contract_address = std::string(native.contract_address),
        };
    }
};

struct Balance {
    Network network;
    AssetType asset_type;
    U256 balance;
    U256 locked_balance;

    static Balance from_native(const ghostbridge_balance_t& native) {
        std::array<uint8_t, 32> balance_bytes;
        std::array<uint8_t, 32> locked_bytes;
        std::copy(native.balance, native.balance + 32, balance_bytes.begin());
        std::copy(native.locked_balance, native.locked_balance + 32, locked_bytes.begin());

        return Balance{
            .network = static_cast<Network>(native.network),
            .asset_type = static_cast<AssetType>(native.asset_type),
            .balance = U256(balance_bytes),
            .locked_balance = U256(locked_bytes),
        };
    }
};

struct TransferRequest {
    Network from_network;
    Network to_network;
    AssetType asset_type;
    U256 amount;
    std::string from_address;
    std::string to_address;
    U256 fee_amount;
    uint64_t nonce;

    ghostbridge_transfer_request_t to_native() const {
        ghostbridge_transfer_request_t native{};
        native.from_network = static_cast<int>(from_network);
        native.to_network = static_cast<int>(to_network);
        native.asset_type = static_cast<int>(asset_type);
        std::copy(amount.bytes().begin(), amount.bytes().end(), native.amount);
        strncpy(native.from_address, from_address.c_str(), 127);
        strncpy(native.to_address, to_address.c_str(), 127);
        std::copy(fee_amount.bytes().begin(), fee_amount.bytes().end(), native.fee_amount);
        native.nonce = nonce;
        return native;
    }
};

struct TransferInfo {
    std::string transfer_id;
    TransferStatus status;
    std::string from_tx_hash;
    std::string to_tx_hash;
    uint32_t confirmations;
    uint32_t required_confirmations;
    std::chrono::system_clock::time_point created_at;
    std::chrono::system_clock::time_point updated_at;

    static TransferInfo from_native(const ghostbridge_transfer_status_t& native) {
        return TransferInfo{
            .transfer_id = std::string(native.transfer_id),
            .status = static_cast<TransferStatus>(native.status),
            .from_tx_hash = std::string(native.from_tx_hash),
            .to_tx_hash = std::string(native.to_tx_hash),
            .confirmations = native.confirmations,
            .required_confirmations = native.required_confirmations,
            .created_at = std::chrono::system_clock::from_time_t(native.created_at),
            .updated_at = std::chrono::system_clock::from_time_t(native.updated_at),
        };
    }
};

class Config {
public:
    Config() = default;

    Config& ethereum_rpc(const std::string& url) {
        ethereum_rpc_url_ = url;
        return *this;
    }

    Config& bitcoin_rpc(const std::string& url) {
        bitcoin_rpc_url_ = url;
        return *this;
    }

    Config& ghostchain_rpc(const std::string& url) {
        ghostchain_rpc_url_ = url;
        return *this;
    }

    Config& confirmation_blocks(uint32_t blocks) {
        confirmation_blocks_ = blocks;
        return *this;
    }

    Config& timeout(std::chrono::seconds timeout) {
        timeout_seconds_ = timeout.count();
        return *this;
    }

    Config& max_gas_price(uint64_t price) {
        max_gas_price_ = price;
        return *this;
    }

    Config& enable_monitoring(bool enable) {
        enable_monitoring_ = enable;
        return *this;
    }

    ghostbridge_config_t to_native() const {
        return ghostbridge_config_t{
            .ethereum_rpc_url = ethereum_rpc_url_.empty() ? nullptr : ethereum_rpc_url_.c_str(),
            .bitcoin_rpc_url = bitcoin_rpc_url_.empty() ? nullptr : bitcoin_rpc_url_.c_str(),
            .ghostchain_rpc_url = ghostchain_rpc_url_.empty() ? nullptr : ghostchain_rpc_url_.c_str(),
            .confirmation_blocks = confirmation_blocks_,
            .timeout_seconds = timeout_seconds_,
            .max_gas_price = max_gas_price_,
            .enable_monitoring = enable_monitoring_ ? 1 : 0,
        };
    }

private:
    std::string ethereum_rpc_url_;
    std::string bitcoin_rpc_url_;
    std::string ghostchain_rpc_url_;
    uint32_t confirmation_blocks_ = 12;
    uint64_t timeout_seconds_ = 300;
    uint64_t max_gas_price_ = 100000000000; // 100 gwei
    bool enable_monitoring_ = true;
};

class Runtime {
public:
    Runtime() : runtime_(ghostbridge_runtime_new()) {
        if (!runtime_) {
            throw BridgeError(GHOSTBRIDGE_ERROR_OUT_OF_MEMORY);
        }
    }

    ~Runtime() {
        if (runtime_) {
            ghostbridge_runtime_free(runtime_);
        }
    }

    // Non-copyable
    Runtime(const Runtime&) = delete;
    Runtime& operator=(const Runtime&) = delete;

    // Movable
    Runtime(Runtime&& other) noexcept : runtime_(other.runtime_) {
        other.runtime_ = nullptr;
    }

    Runtime& operator=(Runtime&& other) noexcept {
        if (this != &other) {
            if (runtime_) {
                ghostbridge_runtime_free(runtime_);
            }
            runtime_ = other.runtime_;
            other.runtime_ = nullptr;
        }
        return *this;
    }

    ghostbridge_runtime_t* native() const { return runtime_; }

private:
    ghostbridge_runtime_t* runtime_;
};

class Transfer {
public:
    explicit Transfer(ghostbridge_transfer_t* transfer) : transfer_(transfer) {}

    ~Transfer() {
        if (transfer_) {
            ghostbridge_transfer_free(transfer_);
        }
    }

    // Non-copyable
    Transfer(const Transfer&) = delete;
    Transfer& operator=(const Transfer&) = delete;

    // Movable
    Transfer(Transfer&& other) noexcept : transfer_(other.transfer_) {
        other.transfer_ = nullptr;
    }

    Transfer& operator=(Transfer&& other) noexcept {
        if (this != &other) {
            if (transfer_) {
                ghostbridge_transfer_free(transfer_);
            }
            transfer_ = other.transfer_;
            other.transfer_ = nullptr;
        }
        return *this;
    }

    ghostbridge_transfer_t* native() const { return transfer_; }

private:
    ghostbridge_transfer_t* transfer_;
};

class Bridge {
public:
    Bridge(Runtime& runtime, const Config& config = Config{})
        : bridge_(ghostbridge_bridge_new(runtime.native(), &config.to_native())) {
        if (!bridge_) {
            throw BridgeError(GHOSTBRIDGE_ERROR_NETWORK_FAILED);
        }
    }

    ~Bridge() {
        if (bridge_) {
            ghostbridge_bridge_free(bridge_);
        }
    }

    // Non-copyable
    Bridge(const Bridge&) = delete;
    Bridge& operator=(const Bridge&) = delete;

    // Movable
    Bridge(Bridge&& other) noexcept : bridge_(other.bridge_) {
        other.bridge_ = nullptr;
    }

    Bridge& operator=(Bridge&& other) noexcept {
        if (this != &other) {
            if (bridge_) {
                ghostbridge_bridge_free(bridge_);
            }
            bridge_ = other.bridge_;
            other.bridge_ = nullptr;
        }
        return *this;
    }

    std::vector<NetworkInfo> get_supported_networks() const {
        ghostbridge_network_t networks[10];
        size_t actual_count;

        int result = ghostbridge_get_supported_networks(
            bridge_,
            networks,
            10,
            &actual_count
        );

        if (result != GHOSTBRIDGE_SUCCESS) {
            throw BridgeError(result);
        }

        std::vector<NetworkInfo> result_networks;
        for (size_t i = 0; i < actual_count; ++i) {
            result_networks.push_back(NetworkInfo::from_native(networks[i]));
        }

        return result_networks;
    }

    std::vector<AssetInfo> get_supported_assets(Network network) const {
        ghostbridge_asset_t assets[20];
        size_t actual_count;

        int result = ghostbridge_get_supported_assets(
            bridge_,
            static_cast<int>(network),
            assets,
            20,
            &actual_count
        );

        if (result != GHOSTBRIDGE_SUCCESS) {
            throw BridgeError(result);
        }

        std::vector<AssetInfo> result_assets;
        for (size_t i = 0; i < actual_count; ++i) {
            result_assets.push_back(AssetInfo::from_native(assets[i]));
        }

        return result_assets;
    }

    Balance get_balance(Network network, AssetType asset_type, const std::string& address) const {
        ghostbridge_balance_t balance;

        int result = ghostbridge_get_balance(
            bridge_,
            static_cast<int>(network),
            static_cast<int>(asset_type),
            address.c_str(),
            &balance
        );

        if (result != GHOSTBRIDGE_SUCCESS) {
            throw BridgeError(result);
        }

        return Balance::from_native(balance);
    }

    std::unique_ptr<Transfer> create_transfer(
        const TransferRequest& request,
        const std::vector<uint8_t>& private_key
    ) {
        auto native_request = request.to_native();

        ghostbridge_transfer_t* transfer = ghostbridge_create_transfer(
            bridge_,
            &native_request,
            private_key.data(),
            private_key.size()
        );

        if (!transfer) {
            throw BridgeError(GHOSTBRIDGE_ERROR_TRANSFER_FAILED);
        }

        return std::make_unique<Transfer>(transfer);
    }

    void submit_transfer(Transfer& transfer) {
        int result = ghostbridge_submit_transfer(bridge_, transfer.native());
        if (result != GHOSTBRIDGE_SUCCESS) {
            throw BridgeError(result);
        }
    }

    TransferInfo get_transfer_status(const std::string& transfer_id) const {
        ghostbridge_transfer_status_t status;

        int result = ghostbridge_get_transfer_status(
            bridge_,
            transfer_id.c_str(),
            &status
        );

        if (result != GHOSTBRIDGE_SUCCESS) {
            throw BridgeError(result);
        }

        return TransferInfo::from_native(status);
    }

private:
    ghostbridge_bridge_t* bridge_;
};

// Utility functions
inline std::string version() {
    return std::string(ghostbridge_version_string());
}

inline std::string network_name(Network network) {
    return std::string(ghostbridge_network_name(static_cast<int>(network)));
}

inline std::string asset_name(AssetType asset_type) {
    return std::string(ghostbridge_asset_name(static_cast<int>(asset_type)));
}

} // namespace ghostbridge

#endif // GHOSTBRIDGE_HPP
```

### C++ Usage Example

```cpp
// example.cpp
#include <iostream>
#include <iomanip>
#include "ghostbridge.hpp"

void print_networks(const ghostbridge::Bridge& bridge);
void test_balance_query(const ghostbridge::Bridge& bridge);
void test_cross_chain_transfer(ghostbridge::Bridge& bridge);

int main() {
    try {
        std::cout << "GhostBridge version: " << ghostbridge::version() << std::endl;

        ghostbridge::Runtime runtime;

        ghostbridge::Config config;
        config.ethereum_rpc("https://mainnet.infura.io/v3/YOUR_KEY")
              .bitcoin_rpc("https://bitcoin-rpc.example.com")
              .ghostchain_rpc("https://rpc.ghostchain.io")
              .confirmation_blocks(12)
              .timeout(std::chrono::minutes(5))
              .max_gas_price(100000000000) // 100 gwei
              .enable_monitoring(true);

        ghostbridge::Bridge bridge(runtime, config);
        std::cout << "✓ GhostBridge initialized successfully" << std::endl;

        print_networks(bridge);
        test_balance_query(bridge);
        test_cross_chain_transfer(bridge);

    } catch (const ghostbridge::BridgeError& e) {
        std::cerr << "Bridge error: " << e.what() << " (code: " << e.code() << ")" << std::endl;
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    std::cout << "GhostBridge example completed!" << std::endl;
    return 0;
}

void print_networks(const ghostbridge::Bridge& bridge) {
    std::cout << "\n=== Supported Networks ===" << std::endl;

    auto networks = bridge.get_supported_networks();
    std::cout << "Found " << networks.size() << " supported networks:" << std::endl;

    for (const auto& network : networks) {
        std::cout << "- " << network.name
                  << " (Chain ID: " << network.chain_id
                  << ", Block time: " << network.block_time.count() << " ms)" << std::endl;

        // Get supported assets for this network
        auto assets = bridge.get_supported_assets(network.network);
        std::cout << "  Assets: ";
        for (size_t i = 0; i < assets.size(); ++i) {
            if (i > 0) std::cout << ", ";
            std::cout << assets[i].symbol;
        }
        std::cout << std::endl;
    }
}

void test_balance_query(const ghostbridge::Bridge& bridge) {
    std::cout << "\n=== Balance Query Test ===" << std::endl;

    try {
        auto balance = bridge.get_balance(
            ghostbridge::Network::Ethereum,
            ghostbridge::AssetType::ETH,
            "0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B"
        );

        std::cout << "✓ Balance query successful" << std::endl;
        std::cout << "Network: " << ghostbridge::network_name(balance.network) << std::endl;
        std::cout << "Asset: " << ghostbridge::asset_name(balance.asset_type) << std::endl;
        std::cout << "Balance: " << balance.balance.to_string() << std::endl;
        std::cout << "Locked: " << balance.locked_balance.to_string() << std::endl;

    } catch (const ghostbridge::BridgeError& e) {
        std::cout << "✗ Balance query failed: " << e.what() << std::endl;
    }
}

void test_cross_chain_transfer(ghostbridge::Bridge& bridge) {
    std::cout << "\n=== Cross-Chain Transfer Test ===" << std::endl;

    try {
        // Create transfer request
        ghostbridge::TransferRequest request{
            .from_network = ghostbridge::Network::Ethereum,
            .to_network = ghostbridge::Network::GhostChain,
            .asset_type = ghostbridge::AssetType::ETH,
            .amount = ghostbridge::U256(1000000000000000000ULL), // 1 ETH in wei
            .from_address = "0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B",
            .to_address = "ghost1abcd1234567890abcd1234567890abcd123456",
            .fee_amount = ghostbridge::U256(1000000000000000ULL), // 0.001 ETH fee
            .nonce = 1,
        };

        // Example private key (DON'T USE IN PRODUCTION)
        std::vector<uint8_t> private_key(32);
        std::iota(private_key.begin(), private_key.end(), 1);

        // Create and submit transfer
        auto transfer = bridge.create_transfer(request, private_key);
        std::cout << "✓ Transfer created successfully" << std::endl;

        bridge.submit_transfer(*transfer);
        std::cout << "✓ Transfer submitted to network" << std::endl;

        // Check status (in real implementation, you'd have the actual transfer ID)
        auto status = bridge.get_transfer_status("example_transfer_id");
        std::cout << "✓ Transfer status: " << static_cast<int>(status.status) << std::endl;
        std::cout << "  Confirmations: " << status.confirmations
                  << "/" << status.required_confirmations << std::endl;

    } catch (const ghostbridge::BridgeError& e) {
        std::cout << "✗ Transfer failed: " << e.what() << std::endl;
    }
}
```

## CMake Integration

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)
project(ghostbridge_example)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find the GhostBridge library
find_library(GHOSTBRIDGE_LIBRARY
    NAMES ghostbridge_c
    PATHS ${CMAKE_SOURCE_DIR}/target/release
    REQUIRED
)

# Find the GhostBridge headers
find_path(GHOSTBRIDGE_INCLUDE_DIR
    NAMES ghostbridge.h
    PATHS ${CMAKE_SOURCE_DIR}/include
    REQUIRED
)

# Create imported target
add_library(ghostbridge::ghostbridge UNKNOWN IMPORTED)
set_target_properties(ghostbridge::ghostbridge PROPERTIES
    IMPORTED_LOCATION ${GHOSTBRIDGE_LIBRARY}
    INTERFACE_INCLUDE_DIRECTORIES ${GHOSTBRIDGE_INCLUDE_DIR}
)

# C example
add_executable(c_bridge bridge_example.c)
target_link_libraries(c_bridge
    ghostbridge::ghostbridge
    pthread
    dl
    m
)

# C++ example
add_executable(cpp_bridge example.cpp)
target_link_libraries(cpp_bridge
    ghostbridge::ghostbridge
    pthread
    dl
    m
)

# Custom target to build Rust library
add_custom_target(build_rust_lib
    COMMAND cargo build --release
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    COMMENT "Building Rust GhostBridge library"
)

# Make sure Rust library is built before our targets
add_dependencies(c_bridge build_rust_lib)
add_dependencies(cpp_bridge build_rust_lib)
```

This completes the GhostBridge C/C++ integration guide. The bindings provide comprehensive cross-chain bridge functionality with strong type safety and error handling while maintaining the security characteristics of the Rust implementation.